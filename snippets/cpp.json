{
	"Template for Competitive Programming": {
		"prefix": "cp-template",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long int",
			"#define endl '\\n'",
			"#define all(v) (v).begin(), (v).end()",
			"",
			"class DisjointSet {",
			"public:",
			"    vector<int> rank, parent, size;",
			"    int components;",
			"",
			"    enum Indexing { ZERO_INDEXED = 0,",
			"                    ONE_INDEXED = 1 };",
			"",
			"    DisjointSet(int n, Indexing mode = ONE_INDEXED) {",
			"        rank.resize(n + mode, 0);",
			"        parent.resize(n + mode);",
			"        size.resize(n + mode, 1);",
			"        components = n;",
			"",
			"        for (int i = 0; i < n + mode; i++) {",
			"            parent[i] = i;",
			"        }",
			"    }",
			"",
			"    int find_root(int node) {",
			"        if (node == parent[node]) {",
			"            return node;",
			"        }",
			"        parent[node] = find_root(parent[node]);",
			"        return parent[node];",
			"    }",
			"",
			"    // true if merged, false if already in same set",
			"    bool union_by_size(int u, int v) {",
			"        int root_u = find_root(u);",
			"        int root_v = find_root(v);",
			"",
			"        if (root_u == root_v) {",
			"            return false;",
			"        }",
			"",
			"        if (size[root_u] < size[root_v]) {",
			"            parent[root_u] = root_v;",
			"            size[root_v] += size[root_u];",
			"        } else {",
			"            parent[root_v] = root_u;",
			"            size[root_u] += size[root_v];",
			"        }",
			"",
			"        components--;",
			"        return true;",
			"    }",
			"",
			"    bool is_connected(int u, int v) {",
			"        return find_root(u) == find_root(v);",
			"    }",
			"};",
			"",
			"bool is_square(int x) {",
			"    int res = sqrt(x);",
			"    while (res * res > x)",
			"        res--;",
			"    while ((res + 1) * (res + 1) <= x)",
			"        res++;",
			"    return res * res == x;",
			"}",
			"",
			"int binary_search(int key, const vector<int> &arr) {",
			"    int left = 0, right = arr.size() - 1;",
			"    while (left <= right) {",
			"        int mid = left + (right - left) / 2;",
			"        if (arr[mid] == key)",
			"            return mid;",
			"        else if (arr[mid] < key)",
			"            left = mid + 1;",
			"        else",
			"            right = mid - 1;",
			"    }",
			"    return -1;",
			"}",
			"",
			"bool is_prime(int n) {",
			"    if (n <= 1) {",
			"        return false;",
			"    }",
			"    if (n <= 3) {",
			"        return true;",
			"    }",
			"",
			"    if (n % 2 == 0 || n % 3 == 0) {",
			"        return false;",
			"    }",
			"",
			"    for (int i = 5; i * i <= n; i += 6) {",
			"        if (n % i == 0 || n % (i + 2) == 0) {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}",
			"",
			"// मन मंदिरा तेजाने उजळून घेई साधका ${CURRENT_DATE}-${CURRENT_MONTH}-${CURRENT_YEAR} ${CURRENT_HOUR}:${CURRENT_MINUTE}",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"signed main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"",
			"    int tc;",
			"    cin >> tc;",
			"",
			"    while (tc--) {",
			"        solve();",
			"    }",
			"",
			"    return 0;",
			"}"
		],
		"description": "Template for competitive programming with macros and testcase loop"
	},
	"Testcase-less Template for Competitive Programming": {
		"prefix": "cp-testcaseless",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long int",
			"#define endl '\\n'",
			"#define all(v) (v).begin(), (v).end()",
			"",
			"class DisjointSet {",
			"public:",
			"    vector<int> rank, parent, size;",
			"    int components;",
			"",
			"    enum Indexing { ZERO_INDEXED = 0,",
			"                    ONE_INDEXED = 1 };",
			"",
			"    DisjointSet(int n, Indexing mode = ONE_INDEXED) {",
			"        rank.resize(n + mode, 0);",
			"        parent.resize(n + mode);",
			"        size.resize(n + mode, 1);",
			"        components = n;",
			"",
			"        for (int i = 0; i < n + mode; i++) {",
			"            parent[i] = i;",
			"        }",
			"    }",
			"",
			"    int find_root(int node) {",
			"        if (node == parent[node]) {",
			"            return node;",
			"        }",
			"        parent[node] = find_root(parent[node]);",
			"        return parent[node];",
			"    }",
			"",
			"    // true if merged, false if already in same set",
			"    bool union_by_size(int u, int v) {",
			"        int root_u = find_root(u);",
			"        int root_v = find_root(v);",
			"",
			"        if (root_u == root_v) {",
			"            return false;",
			"        }",
			"",
			"        if (size[root_u] < size[root_v]) {",
			"            parent[root_u] = root_v;",
			"            size[root_v] += size[root_u];",
			"        } else {",
			"            parent[root_v] = root_u;",
			"            size[root_u] += size[root_v];",
			"        }",
			"",
			"        components--;",
			"        return true;",
			"    }",
			"",
			"    bool is_connected(int u, int v) {",
			"        return find_root(u) == find_root(v);",
			"    }",
			"};",
			"",
			"bool is_square(int x) {",
			"    int res = sqrt(x);",
			"    while (res * res > x)",
			"        res--;",
			"    while ((res + 1) * (res + 1) <= x)",
			"        res++;",
			"    return res * res == x;",
			"}",
			"",
			"int binary_search(int key, const vector<int> &arr) {",
			"    int left = 0, right = arr.size() - 1;",
			"    while (left <= right) {",
			"        int mid = left + (right - left) / 2;",
			"        if (arr[mid] == key)",
			"            return mid;",
			"        else if (arr[mid] < key)",
			"            left = mid + 1;",
			"        else",
			"            right = mid - 1;",
			"    }",
			"    return -1;",
			"}",
			"",
			"bool is_prime(int n) {",
			"    if (n <= 1) {",
			"        return false;",
			"    }",
			"    if (n <= 3) {",
			"        return true;",
			"    }",
			"",
			"    if (n % 2 == 0 || n % 3 == 0) {",
			"        return false;",
			"    }",
			"",
			"    for (int i = 5; i * i <= n; i += 6) {",
			"        if (n % i == 0 || n % (i + 2) == 0) {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}",
			"",
			"// मन मंदिरा तेजाने उजळून घेई साधका ${CURRENT_DATE}-${CURRENT_MONTH}-${CURRENT_YEAR} ${CURRENT_HOUR}:${CURRENT_MINUTE} tcl",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"signed main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"",
			"    solve();",
			"",
			"    return 0;",
			"}"
		],
		"description": "C++ template for competitive programming - Test Case Less"
	},
	"Input Vector from User": {
		"prefix": "iv",
		"body": [
			"int n;",
			"cin >> n;",
			"",
			"vector<int> vect(n);",
			"",
			"for (int i = 0; i < n; i++) {",
			"    cin >> vect[i];",
			"}",
			""
		],
		"description": "Snippet to input a vector from user in competitive programming"
	},
	"For Loop from i = 0 to i < n": {
		"prefix": "fori",
		"body": [
			"for (int i = 0; i < n; i++) {",
			"\t$0",
			"}"
		],
		"description": "For loop from i = 0 to i < n"
	},
	"For Loop from j = 0 to j < n": {
		"prefix": "forj",
		"body": [
			"for (int j = 0; j < n; j++) {",
			"\t$0",
			"}"
		],
		"description": "For loop from i = 0 to i < n"
	},
	"Factorial Function": {
		"prefix": "factorial",
		"body": [
			"long long factorial(int n) {",
			"    long long fact = 1;",
			"    for (int i = 2; i <= n; i++) {",
			"        fact *= i;",
			"    }",
			"    return fact;",
			"}"
		],
		"description": "Returns the factorial of a number using an iterative approach."
	}
}